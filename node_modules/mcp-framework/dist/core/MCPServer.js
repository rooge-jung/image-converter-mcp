import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "../transports/stdio/server.js";
import { CallToolRequestSchema, ListToolsRequestSchema, ListPromptsRequestSchema, GetPromptRequestSchema, ListResourcesRequestSchema, ReadResourceRequestSchema, SubscribeRequestSchema, UnsubscribeRequestSchema, } from "@modelcontextprotocol/sdk/types.js";
import { readFileSync } from "fs";
import { join, dirname } from "path";
import { logger } from "./Logger.js";
import { ToolLoader } from "../loaders/toolLoader.js";
import { PromptLoader } from "../loaders/promptLoader.js";
import { ResourceLoader } from "../loaders/resourceLoader.js";
import { SSEServerTransport } from "../transports/sse/server.js";
import { DEFAULT_SSE_CONFIG } from "../transports/sse/types.js";
export class MCPServer {
    server;
    toolsMap = new Map();
    promptsMap = new Map();
    resourcesMap = new Map();
    toolLoader;
    promptLoader;
    resourceLoader;
    serverName;
    serverVersion;
    basePath;
    transportConfig;
    capabilities = {
        tools: { enabled: true }
    };
    isRunning = false;
    transport;
    shutdownPromise;
    shutdownResolve;
    constructor(config = {}) {
        this.basePath = this.resolveBasePath(config.basePath);
        this.serverName = config.name ?? this.getDefaultName();
        this.serverVersion = config.version ?? this.getDefaultVersion();
        this.transportConfig = config.transport ?? { type: "stdio" };
        logger.info(`Initializing MCP Server: ${this.serverName}@${this.serverVersion}`);
        this.toolLoader = new ToolLoader(this.basePath);
        this.promptLoader = new PromptLoader(this.basePath);
        this.resourceLoader = new ResourceLoader(this.basePath);
        logger.debug(`Looking for tools in: ${join(dirname(this.basePath), 'tools')}`);
        logger.debug(`Looking for prompts in: ${join(dirname(this.basePath), 'prompts')}`);
        logger.debug(`Looking for resources in: ${join(dirname(this.basePath), 'resources')}`);
    }
    resolveBasePath(configPath) {
        if (configPath) {
            return configPath;
        }
        if (process.argv[1]) {
            return process.argv[1];
        }
        return process.cwd();
    }
    createTransport() {
        logger.debug(`Creating transport: ${this.transportConfig.type}`);
        let transport;
        switch (this.transportConfig.type) {
            case "sse": {
                const sseConfig = this.transportConfig.options
                    ? { ...DEFAULT_SSE_CONFIG, ...this.transportConfig.options }
                    : DEFAULT_SSE_CONFIG;
                transport = new SSEServerTransport(sseConfig);
                break;
            }
            case "stdio":
                logger.info("Starting stdio transport");
                transport = new StdioServerTransport();
                break;
            default:
                throw new Error(`Unsupported transport type: ${this.transportConfig.type}`);
        }
        transport.onclose = () => {
            logger.info("Transport connection closed");
            this.stop().catch(error => {
                logger.error(`Error during shutdown: ${error}`);
                process.exit(1);
            });
        };
        transport.onerror = (error) => {
            logger.error(`Transport error: ${error}`);
        };
        return transport;
    }
    readPackageJson() {
        try {
            const projectRoot = process.cwd();
            const packagePath = join(projectRoot, "package.json");
            try {
                const packageContent = readFileSync(packagePath, "utf-8");
                const packageJson = JSON.parse(packageContent);
                logger.debug(`Successfully read package.json from project root: ${packagePath}`);
                return packageJson;
            }
            catch (error) {
                logger.warn(`Could not read package.json from project root: ${error}`);
                return null;
            }
        }
        catch (error) {
            logger.warn(`Could not read package.json: ${error}`);
            return null;
        }
    }
    getDefaultName() {
        const packageJson = this.readPackageJson();
        if (packageJson?.name) {
            logger.info(`Using name from package.json: ${packageJson.name}`);
            return packageJson.name;
        }
        logger.error("Couldn't find project name in package json");
        return "unnamed-mcp-server";
    }
    getDefaultVersion() {
        const packageJson = this.readPackageJson();
        if (packageJson?.version) {
            logger.info(`Using version from package.json: ${packageJson.version}`);
            return packageJson.version;
        }
        return "0.0.0";
    }
    setupHandlers() {
        this.server.setRequestHandler(ListToolsRequestSchema, async (request) => {
            logger.debug(`Received ListTools request: ${JSON.stringify(request)}`);
            const tools = Array.from(this.toolsMap.values()).map((tool) => tool.toolDefinition);
            logger.debug(`Found ${tools.length} tools to return`);
            logger.debug(`Tool definitions: ${JSON.stringify(tools)}`);
            const response = {
                tools: tools,
                nextCursor: undefined
            };
            logger.debug(`Sending ListTools response: ${JSON.stringify(response)}`);
            return response;
        });
        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            logger.debug(`Tool call request received for: ${request.params.name}`);
            logger.debug(`Tool call arguments: ${JSON.stringify(request.params.arguments)}`);
            const tool = this.toolsMap.get(request.params.name);
            if (!tool) {
                const availableTools = Array.from(this.toolsMap.keys());
                const errorMsg = `Unknown tool: ${request.params.name}. Available tools: ${availableTools.join(", ")}`;
                logger.error(errorMsg);
                throw new Error(errorMsg);
            }
            try {
                logger.debug(`Executing tool: ${tool.name}`);
                const toolRequest = {
                    params: request.params,
                    method: "tools/call",
                };
                const result = await tool.toolCall(toolRequest);
                logger.debug(`Tool execution successful: ${JSON.stringify(result)}`);
                return result;
            }
            catch (error) {
                const errorMsg = `Tool execution failed: ${error}`;
                logger.error(errorMsg);
                throw new Error(errorMsg);
            }
        });
        if (this.capabilities.prompts) {
            this.server.setRequestHandler(ListPromptsRequestSchema, async () => {
                return {
                    prompts: Array.from(this.promptsMap.values()).map((prompt) => prompt.promptDefinition),
                };
            });
            this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
                const prompt = this.promptsMap.get(request.params.name);
                if (!prompt) {
                    throw new Error(`Unknown prompt: ${request.params.name}. Available prompts: ${Array.from(this.promptsMap.keys()).join(", ")}`);
                }
                return {
                    messages: await prompt.getMessages(request.params.arguments),
                };
            });
        }
        if (this.capabilities.resources) {
            this.server.setRequestHandler(ListResourcesRequestSchema, async () => {
                return {
                    resources: Array.from(this.resourcesMap.values()).map((resource) => resource.resourceDefinition),
                };
            });
            this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
                const resource = this.resourcesMap.get(request.params.uri);
                if (!resource) {
                    throw new Error(`Unknown resource: ${request.params.uri}. Available resources: ${Array.from(this.resourcesMap.keys()).join(", ")}`);
                }
                return {
                    contents: await resource.read(),
                };
            });
            this.server.setRequestHandler(SubscribeRequestSchema, async (request) => {
                const resource = this.resourcesMap.get(request.params.uri);
                if (!resource) {
                    throw new Error(`Unknown resource: ${request.params.uri}`);
                }
                if (!resource.subscribe) {
                    throw new Error(`Resource ${request.params.uri} does not support subscriptions`);
                }
                await resource.subscribe();
                return {};
            });
            this.server.setRequestHandler(UnsubscribeRequestSchema, async (request) => {
                const resource = this.resourcesMap.get(request.params.uri);
                if (!resource) {
                    throw new Error(`Unknown resource: ${request.params.uri}`);
                }
                if (!resource.unsubscribe) {
                    throw new Error(`Resource ${request.params.uri} does not support subscriptions`);
                }
                await resource.unsubscribe();
                return {};
            });
        }
    }
    async detectCapabilities() {
        if (await this.promptLoader.hasPrompts()) {
            this.capabilities.prompts = { enabled: true };
            logger.debug("Prompts capability enabled");
        }
        if (await this.resourceLoader.hasResources()) {
            this.capabilities.resources = { enabled: true };
            logger.debug("Resources capability enabled");
        }
        return this.capabilities;
    }
    async start() {
        try {
            if (this.isRunning) {
                throw new Error("Server is already running");
            }
            const tools = await this.toolLoader.loadTools();
            this.toolsMap = new Map(tools.map((tool) => [tool.name, tool]));
            const prompts = await this.promptLoader.loadPrompts();
            this.promptsMap = new Map(prompts.map((prompt) => [prompt.name, prompt]));
            const resources = await this.resourceLoader.loadResources();
            this.resourcesMap = new Map(resources.map((resource) => [resource.uri, resource]));
            await this.detectCapabilities();
            logger.debug("Creating MCP Server instance");
            this.server = new Server({
                name: this.serverName,
                version: this.serverVersion,
            }, {
                capabilities: this.capabilities
            });
            logger.debug(`Server created with capabilities: ${JSON.stringify(this.capabilities)}`);
            this.setupHandlers();
            logger.info("Starting transport...");
            this.transport = this.createTransport();
            const originalTransportSend = this.transport.send.bind(this.transport);
            this.transport.send = async (message) => {
                logger.debug(`Transport sending message: ${JSON.stringify(message)}`);
                return originalTransportSend(message);
            };
            this.transport.onmessage = async (message) => {
                logger.debug(`Transport received message: ${JSON.stringify(message)}`);
                try {
                    if (message.method === 'initialize') {
                        logger.debug('Processing initialize request');
                        await this.transport?.send({
                            jsonrpc: "2.0",
                            id: message.id,
                            result: {
                                protocolVersion: "2024-11-05",
                                capabilities: this.capabilities,
                                serverInfo: {
                                    name: this.serverName,
                                    version: this.serverVersion
                                }
                            }
                        });
                        await this.transport?.send({
                            jsonrpc: "2.0",
                            method: "server/ready",
                            params: {}
                        });
                        logger.debug('Initialization sequence completed');
                        return;
                    }
                    if (message.method === 'tools/list') {
                        logger.debug('Processing tools/list request');
                        const tools = Array.from(this.toolsMap.values()).map((tool) => tool.toolDefinition);
                        await this.transport?.send({
                            jsonrpc: "2.0",
                            id: message.id,
                            result: {
                                tools,
                                nextCursor: undefined
                            }
                        });
                        return;
                    }
                    logger.debug(`Unhandled message method: ${message.method}`);
                }
                catch (error) {
                    logger.error(`Error handling message: ${error}`);
                    if ('id' in message) {
                        await this.transport?.send({
                            jsonrpc: "2.0",
                            id: message.id,
                            error: {
                                code: -32000,
                                message: String(error),
                                data: { type: "handler_error" }
                            }
                        });
                    }
                }
            };
            await this.server.connect(this.transport);
            logger.info("Transport connected successfully");
            logger.info(`Started ${this.serverName}@${this.serverVersion}`);
            logger.info(`Transport: ${this.transportConfig.type}`);
            if (tools.length > 0) {
                logger.info(`Tools (${tools.length}): ${Array.from(this.toolsMap.keys()).join(", ")}`);
            }
            if (prompts.length > 0) {
                logger.info(`Prompts (${prompts.length}): ${Array.from(this.promptsMap.keys()).join(", ")}`);
            }
            if (resources.length > 0) {
                logger.info(`Resources (${resources.length}): ${Array.from(this.resourcesMap.keys()).join(", ")}`);
            }
            this.isRunning = true;
            process.on('SIGINT', () => {
                logger.info('Shutting down...');
                this.stop().catch(error => {
                    logger.error(`Error during shutdown: ${error}`);
                    process.exit(1);
                });
            });
            this.shutdownPromise = new Promise((resolve) => {
                this.shutdownResolve = resolve;
            });
            logger.info("Server running and ready for connections");
            await this.shutdownPromise;
        }
        catch (error) {
            logger.error(`Server initialization error: ${error}`);
            throw error;
        }
    }
    async stop() {
        if (!this.isRunning) {
            return;
        }
        try {
            logger.info("Stopping server...");
            await this.transport?.close();
            await this.server?.close();
            this.isRunning = false;
            logger.info('Server stopped');
            this.shutdownResolve?.();
            process.exit(0);
        }
        catch (error) {
            logger.error(`Error stopping server: ${error}`);
            throw error;
        }
    }
}
