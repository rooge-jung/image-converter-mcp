import { z } from "zod";
export type PromptArgumentSchema<T> = {
    [K in keyof T]: {
        type: z.ZodType<T[K]>;
        description: string;
        required?: boolean;
    };
};
export type PromptArguments<T extends PromptArgumentSchema<any>> = {
    [K in keyof T]: z.infer<T[K]["type"]>;
};
export interface PromptProtocol {
    name: string;
    description: string;
    promptDefinition: {
        name: string;
        description: string;
        arguments?: Array<{
            name: string;
            description: string;
            required?: boolean;
        }>;
    };
    getMessages(args?: Record<string, unknown>): Promise<Array<{
        role: string;
        content: {
            type: string;
            text: string;
            resource?: {
                uri: string;
                text: string;
                mimeType: string;
            };
        };
    }>>;
}
export declare abstract class MCPPrompt<TArgs extends Record<string, any> = {}> implements PromptProtocol {
    abstract name: string;
    abstract description: string;
    protected abstract schema: PromptArgumentSchema<TArgs>;
    get promptDefinition(): {
        name: string;
        description: string;
        arguments: {
            name: string;
            description: any;
            required: any;
        }[];
    };
    protected abstract generateMessages(args: TArgs): Promise<Array<{
        role: string;
        content: {
            type: string;
            text: string;
            resource?: {
                uri: string;
                text: string;
                mimeType: string;
            };
        };
    }>>;
    getMessages(args?: Record<string, unknown>): Promise<{
        role: string;
        content: {
            type: string;
            text: string;
            resource?: {
                uri: string;
                text: string;
                mimeType: string;
            };
        };
    }[]>;
    protected fetch<T>(url: string, init?: RequestInit): Promise<T>;
}
