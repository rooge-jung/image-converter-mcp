import { z } from "zod";
export class MCPTool {
    useStringify = true;
    get inputSchema() {
        const properties = {};
        const required = [];
        Object.entries(this.schema).forEach(([key, schema]) => {
            // Determine the correct JSON schema type (unwrapping optional if necessary)
            const jsonType = this.getJsonSchemaType(schema.type);
            properties[key] = {
                type: jsonType,
                description: schema.description,
            };
            // If the field is not an optional, add it to the required array.
            if (!(schema.type instanceof z.ZodOptional)) {
                required.push(key);
            }
        });
        const inputSchema = {
            type: "object",
            properties,
        };
        if (required.length > 0) {
            inputSchema.required = required;
        }
        return inputSchema;
    }
    get toolDefinition() {
        return {
            name: this.name,
            description: this.description,
            inputSchema: this.inputSchema,
        };
    }
    async toolCall(request) {
        try {
            const args = request.params.arguments || {};
            const validatedInput = await this.validateInput(args);
            const result = await this.execute(validatedInput);
            return this.createSuccessResponse(result);
        }
        catch (error) {
            return this.createErrorResponse(error);
        }
    }
    async validateInput(args) {
        const zodSchema = z.object(Object.fromEntries(Object.entries(this.schema).map(([key, schema]) => [key, schema.type])));
        return zodSchema.parse(args);
    }
    getJsonSchemaType(zodType) {
        // Unwrap optional types to correctly determine the JSON schema type.
        let currentType = zodType;
        if (currentType instanceof z.ZodOptional) {
            currentType = currentType.unwrap();
        }
        if (currentType instanceof z.ZodString)
            return "string";
        if (currentType instanceof z.ZodNumber)
            return "number";
        if (currentType instanceof z.ZodBoolean)
            return "boolean";
        if (currentType instanceof z.ZodArray)
            return "array";
        if (currentType instanceof z.ZodObject)
            return "object";
        return "string";
    }
    createSuccessResponse(data) {
        if (this.isImageContent(data)) {
            return {
                content: [data],
            };
        }
        if (Array.isArray(data)) {
            const validContent = data.filter(item => this.isValidContent(item));
            if (validContent.length > 0) {
                return {
                    content: validContent,
                };
            }
        }
        return {
            content: [{
                    type: "text",
                    text: this.useStringify ? JSON.stringify(data) : String(data)
                }],
        };
    }
    createErrorResponse(error) {
        return {
            content: [{ type: "error", text: error.message }],
        };
    }
    isImageContent(data) {
        return (typeof data === "object" &&
            data !== null &&
            "type" in data &&
            data.type === "image" &&
            "data" in data &&
            "mimeType" in data &&
            typeof data.data === "string" &&
            typeof data.mimeType === "string");
    }
    isTextContent(data) {
        return (typeof data === "object" &&
            data !== null &&
            "type" in data &&
            data.type === "text" &&
            "text" in data &&
            typeof data.text === "string");
    }
    isErrorContent(data) {
        return (typeof data === "object" &&
            data !== null &&
            "type" in data &&
            data.type === "error" &&
            "text" in data &&
            typeof data.text === "string");
    }
    isValidContent(data) {
        return (this.isImageContent(data) ||
            this.isTextContent(data) ||
            this.isErrorContent(data));
    }
    async fetch(url, init) {
        const response = await fetch(url, init);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    }
}
